<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ?
            'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' :
            'https://ptteng.github.io/PPT/css/reveal/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>

<body>
    <img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
    <map name="pttmap">
        <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank" />
    </map>
    <div class="reveal">
        <div class="slides">
            <section>
                <h4>简述JS中this的指向？</h4>
                <h4>分享人：林璇</h4>
            </section>
            <section>
                <p>目录</p>
                <p>1.背景介绍</p>
                <p>2.知识剖析</p>
                <p>3.常见问题</p>
                <p>4.解决方案</p>
                <p>5.编码实战</p>
                <p>6.扩展思考</p>
                <p>7.参考文献</p>
                <p>8.更多讨论</p>
            </section>

            <section>
                <h3>1.背景介绍</h3>
            </section>

            <section style="font-family: 'Times New Roman'; text-transform:none;">
                <!-- <h4 style="font-family: 'Times New Roman'; text-transform:none;">什么是Ajax？</h4> -->
                <section>
                    <p style="text-align: left;">
                        在面向对象的语言中（例如Java,C#等)，this含义是明确且具体的，即指向当前对象
                        <br> 一般在编译期绑定。而在javascript中，this是动态绑定的，它可以是全局对象、当前对象或者任意对象，
                        <br> 这完全取决于函数的调用方式，并且在严格模式下也有不同，这就导致了this具备了多重含义，
                        <br> 可以使得javascript更灵活的使用。但是，带来了灵活性的同时也会给我们初学者带来不少困惑。即使是细微的语法变化，都有可能意外改变this的值。
                        <!-- <br>在JS中有多种页面传递参数的方法： -->
                        <!-- <br>一、URL -->
                        <!-- <br>把参数值附在url后面传递到其他页面 -->
                        <!-- <br>二、H5 web storage -->
                        <!-- <br>localStroage 和 sessionStorage -->
                    </p>
                </section>
                <section>
                    <p style="text-align: left;">
                        <!-- 三、Cookie -->
                        <!-- <br> 使用浏览器Cookie传递参数 -->
                        <!-- <br>四、Form 表单 -->
                        <!-- <br>Form表单通过URL传递参数 -->
                    </p>
                </section>
            </section>
            <section>
                <h3>2.知识剖析</h3>
            </section>

            <section>
                <section>
                    <p style="text-align: left;">
                        JSON (JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。
                        <br> 1&gt;.
                        <br>相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript
                        <br>
                    </p>
                </section>
                <section style="font-family: 'Times New Roman'; text-transform:none;">
                    <p style="text-align: left;">
                        JavaScript中函数的调用有以下几种方式：作为对象方法调用，作为函数调用，作为构造函数调用，和使用apply 或 call 调用。
                        <br>下面我们将按照调用方式的不同，分别讨论this 的含义
                        <br>// console.log(this === window);  //true  // console.log(window.a);  //37// 
                        <br>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this 都指代全局对象。
                        <!-- <br>字符串必须使用双引号表示，不能使用单引号。
                        <br>对象的键名必须放在双引号里面。
                        <br>数组或对象最后一个成员的后面，不能加逗号。
                        <br>ps:注意，null、空数组和空对象都是合法的 JSON 值。 -->
                    </p>
                </section>
                <section style="font-family: 'Times New Roman'; text-transform:none;">
                    <p style="text-align: left;">
                        2.函数上下文
                        <br>// function makeNoSense(x)  
                        <br>{//     this.x = x;// }
                        <br>//// makeNoSense(5);
                        <br>// console.log(x);//
                        <br> window里的x(就是该全局对象)
                    </p>
                </section>
                <section style="font-family: 'Times New Roman'; text-transform:none;">
                    <p style="text-align: left;">
                        <br>3.bind方法
                        <br>// function f()
                        <br>{    return this.a; }
                        <br>var g = f.bind({a:"matt"});
                        <br>// console.log(g());
                        <br>// var h = g.bind({a:'Danny'});
                        <br>// console.log(h());//
                        <br>bind只生效一次//调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，这个参数不能被重写。
                    </p>
                </section>
                <section style="font-family: 'Times New Roman'; text-transform:none;">
                    <p style="text-align: left;">
                        4.作为对象的方法
                        <br>var point = {    x : 0,    y : 0,    moveTo : function(x, y) {        this.x = this.x + x;        this.y = this.y + y;    }};point.moveTo(1, 1);console.log(point.x);console.log(point.y);
                        <br>在JavaScript 中，函数也是对象，因此函数可以作为一个对象的属性，此时该函数被称为该对象的方法，在使用这种调用方式时，this 被自然绑定到该对象。
                    </p>
                </section>
                <section style="font-family: 'Times New Roman'; text-transform:none;">
                    <p style="text-align: left;">
                        5.原型链中的this
                        <br>// var o = {/ f: function() {return this.a + this.b; } }; 
                        var p = Object.create(o);               
                        p.a = 1;                  
                         p.b = 4;                       
                        console.log(p.f());
                    </p>
                </section>
                <section style="font-family: 'Times New Roman'; text-transform:none;">
                    <p style="text-align: left;">
                        6.getter 与 setter 中的 this
                        <br>var o = { a: 1,  b: 2, c: 3, get average()  return (this.a + this.b + this.c) / 3;}}
                        console.log(o.average);                      
                        用作getter 或 setter 的函数都会把 this 绑定到设置或获取属性的对象。也就是O
                    </p>
                </section>
                <section style="font-family: 'Times New Roman'; text-transform:none;">
                    <p style="text-align: left;">
                        7.作为构造函数调用function Point(x, y)
                        <br>{ this.x = x;this.y = y;}

                        var obj=new Point(1,3);
                        
                        console.log(obj.x);
                        
                        console.log(obj.y);
                        
                        function C()
                        
                        {this.a = 37;}
                        
                        var o = new C();
                        
                        console.log(o.a);  logs 37 
                        
                        function C2(){ this.a = 37;return {a:38}; }
                        
                        o = new C2();// console.log(o);
                        
                         console.log(o.a); // logs 38
                        
                        当一个函数用作构造函数时（使用new关键字），它的this被绑定到正在构造的新对象。
                    </p>
                </section>
                <section style="font-family: 'Times New Roman'; text-transform:none;">
                    <p style="text-align: left;">
                        8.在事件处理中
                        <br>在事件处理中// 

                        $(document).ready(function ()
                        
                         { $(".blue").click(function () 
                        
                        { $(this).css("background-color","orange"); }) });
                        
                        它的this指向触发事件的元素
                        
                        当我们点击的时候,this指向了触发时间的p元素。
                    </p>
                </section>
                <section style="font-family: 'Times New Roman'; text-transform:none;">
                    <p style="text-align: left;">
                        9.作为一个内联事件处理函数
                        <br>它的this指向监听器所在的DOM元素

                        button onclick="alert(this.tagName.toLowerCase());">
                            Show this
                        button
                        div它的this指向监听器所在的DOM元素
                        button onclick="alert((function(){return this})());"
                            Show inner this
                        没有设置内部函数的this，所以它指向 global/window 对象
                        虽然this只是JavaScript 中一个很小的概念，但借此我们可以深入了解 JavaScript 中函数的执行环境，而这是理解闭包等其他概念的基础。掌握了这些概念，才能充分发挥 JavaScript 的特点，才会发现 JavaScript 语言特性的强大。
                    </p>
                </section>
            </section>
            <section>
                <h3>3.常见问题</h3>
                <br>内部函数

                var point = {
                
                x :0,
                
                y :0,
                
                moveTo :function(x, y) {
                
                // 内部函数
                
                        var moveX =function(x) {
                
                this.x = x;//this 绑定到了哪里？
                
                        };
                
                // 内部函数
                
                        var moveY =function(y) {
                
                this.y = y;//this 绑定到了哪里？
                
                        };
                
                moveX(x);
                
                moveY(y);
                
                }
                
                };
                
                point.moveTo(1,1);
                
                // console.log(point.x);
                
                // console.log(point.y);
                
                console.log(x);
                
                console.log(y);
                
                这属于 JavaScript 的设计缺陷，正确的设计方式是内部函数的this 应该绑定到其外层函数对应的对象上，
                为了规避这一设计缺陷，聪明的 JavaScript 程序员想出了变量替代的方法，约定俗成，该变量一般被命名为 that
            </section>
            <section>
                <h3>4.解决方案</h3>
                <p> var point = {

                    x :0,
                    
                    y :0,
                    
                    moveTo :function(x, y) {
                    
                    var that =this;
                    
                    // 内部函数
                    
                            var moveX =function(x) {
                    
                    that.x = x;
                    
                    };
                    
                    // 内部函数
                    
                            var moveY =function(y) {
                    
                    that.y = y;
                    
                    };
                    
                    moveX(x);
                    
                    moveY(y);
                    
                    }
                    
                    };
                    
                    point.moveTo(1,1);
                    
                    console.log(point.x);
                    
                    console.log(point.y);
                    
                    console.log(x);
                    
                    console.log(y);
                </p>
            </section>
            <section class="" style="top: 275px; display: none;" aria-hidden="true">
                <h6>
                    <a href="https://ptteng.github.io/WEB/demo/angular%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E6%98%AF%E4%BB%80%E4%B9%88/demo2.html"
                        target="_blank">demo</a>
                </h6>
            </section>
            <section>
                <h3>5.编码实战</h3>
            </section>
            <section>
                <h3>6.扩展思考</h3>
            </section>
            <section>
                <section class="past" style="top: 278.5px; display: none;" hidden="" aria-hidden="true">
                    <h5></h5>
                </section>
                <section class="past" style="top: 0px; display: none;" hidden="" aria-hidden="true">
                    <p style="text-align: left;">
                        <br> 如何能加深记忆？（this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的。）

                        严格模式下的this

                        <span ng-bind="goods.goodsID"></span>
                        <!-- <br> 6.
                        <span ng-bind="goods.goodsPrice*goods.count"></span> 总价就是单价乘以数量
                        <br> 7.
                        <span ng-bind="goods.goodsPrice*goods.count| currency"></span> 单价和总价格式化成美元形式。 -->
                        <br>
                        <br>
                        <br>
                    </p>
                </section>
            </section>

            <section>
                <h3>7.参考文献</h3>
            </section>
            <section style="text-align:left">
                <h6>
                    <a>博客</a>
                </h6>
                <h6>
                    <a>b站视频</a>
                </h6>

            </section>
            <section>
                <h3>8.更多讨论</h3>

            </section>
            <section>
                <p> 1.如果想让一个this指向函数内部，但是它指向了全局，有什么办法让它指向函数内部？
                    <br>
                </p>
                <p>
                   2.内联元素的this可以再讲一下吗？
                </p>
                <p>
                    3.简单说一下this 到底有几种指向？
                </p>
            </section>
            <section style="text-align:left">
                <p>
                    使用call方法或者apply方法给它指定this，或者把他作为对象的方法调用
                </p>
                <p>
                    内联元素中的this指向了它所在的dom对象，没有设置内部函数的this，所以它指向 global/window 对象
                </p>
                <p>
                     我们重点掌握作为对象方法调用，作为函数调用，作为构造函数调用，和使用apply 或 call 调用这几种，其他的情况了解即可，请牢记一点，

                        this永远指向的是最后调用它的对象，也就是看它执行的时候是谁调用的。
                </p>
            </section>
            <section>
                <h4>鸣谢</h4>
                <p>感谢大家观看</p>
                <p>
                    By
                    <small style="vertical-align: middle">林璇</small>
                </p>

            </section>

        </div>
    </div>

    <script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
    <script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

    <script>
        // 以下为常见配置属性的默认值
        // {
        // 	controls: true, // 是否在右下角展示控制条
        // 	progress: true, // 是否显示演示的进度条
        // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
        // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
        // 	keyboard: true, // 是否启用键盘快捷键来导航
        // 	overview: true, //                                                                                                                                                                                                                                                                                                      是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
        // 	center: true, // 是否将幻灯片垂直居中
        // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
        // 	loop: false, // 是否循环演示
        // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
        // 	fragments: true, // 全局开启和关闭碎片。
        // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
        // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
        // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
        // 	mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
        // }

        // 初始化幻灯片
        Reveal.initialize({
            //        history: true,
            transition: 'default',
            transitionSpeed: 'slow',
            dependencies: [{
                    src: '../plugin/markdown/marked.js'
                },
                {
                    src: '../plugin/markdown/markdown.js'
                },
                {
                    src: '../plugin/notes/notes.js',
                    async: true
                },
                {
                    src: '../plugin/highlight/highlight.js',
                    async: true,
                    callback: function () {
                        hljs.initHighlightingOnLoad();
                    }
                }
            ]
        });
        //    原始类型对象直接赋值不会相互影响
        //    var a = 1;
        //
        //    var b = a;
        //    b = 10;
        //    console.log(a); // 1
        ////
        //    var a = 'hello';
        //    var b = a;
        //    b = 'world';
        //    console.log(a); // hello
        //
        //    var a = true;
        //    var b = a;
        //    b = false;
        //    console.log(a);

        //数组浅复制
        //    var a = ['隔壁老王','冠希哥', '宋经理' //定义一个名为a的属猪，里面有3个值，
        //    ];
        //    var b = a;   //定义一个变量b，把a赋值给他，这样比、b和a一样了
        //    b[2] = '冲冲老师'; //然后把b的第三个值等于冲冲老师
        //    console.log(a)//那么现在打印a 是什么结果呢
        //
        //    var arr = ["One","Two","Three"];   //数组的深复制，slice方法
        //    var arrtoo = arr.slice(1);
        //    arrtoo[2] = "set Map";
        //    console.log(arr);//One,Two,Three
        //    console.log(arrtoo);//One,set Map,Three

        //
        //    var arr1 = ["One","Two","Three"]; //数组的深复制，concat 方法
        //    var arrtooo = arr1.concat(111111);
        //    arrtooo[1] = "set Map To";
        //    console.log(arr1);//One,Two,Three
        //    console.log(arrtooo);//One,set Map To,Three

        //
        //    var b=[1,2,3,4,5];   //concat的链接
        //    var c=[6,7,8,9];
        //    var d =[4,4,22]
        //    console.log(b.concat(c,d))

        var a = {
            name: 'yy',
            age: 26
        }; //对象的浅拷贝哦
        var b = new Object();
        b.name = a.name;
        b.age = a.age;
        b.name = 'xx';
        console.log(a); //Object { name="yy", age=26}
        console.log(b); //Object { name="xx", age=26}

        var d = { //对象的浅拷贝哦 第一种
            name: 'd',
            oc: {
                age: 32
            },
            oad: {
                adds: {
                    bb: 12
                }
            }
        };
        var deepCopy = function (source) {
            var result = {};
            for (var key in source) {
                result[key] = typeof source[key] === 'object' ? deepCopy(source[key]) : source[key]
            }
            return result
        };

        var c = deepCopy(d);
        c.name = 'c';
        c.oc = {
            age: 49
        };
        console.log(c);
        console.log(d);




        //    var person = {    //第二种深拷贝
        //        name: 'aa',
        //        friends: ['da', 'dsa', 'gf']
        //    };
        //
        //    var aPerson = Object.create(person, {
        ////        name: {
        ////            value: "gee"
        ////        }
        //    });
        //
        //    console.log(person.name);
        //    console.log(aPerson.friends)

        var Chinese = {
            nation: '中国'

        }
        var Doctor = {
            career: '医生'
        }

        function extendCopy(p) {
            var c = {};
            for (var i in p) {
                c[i] = p[i];
            }
            c.uber = p;
            return c;
        }
        var Doctor = extendCopy(Chinese);
        Doctor.career = '医生';
        console.log(Doctor); // 中国
        Chinese.birthPlaces = ['北京', '上海', '香港'];
        var Doctor = extendCopy(Chinese);
        Doctor.birthPlaces.push('厦门');
    </script>
</body>

</html>